## Running External Commands from Scripts in Linux

In Linux scripting, executing external commands is a common task. Below, I'll provide an in-depth explanation in markdown format:

### 1. **Using Backticks:**

The simplest way to run an external command is by using backticks or the `$()` syntax.

```bash
#!/bin/bash

result=$(ls -l)
echo "Command output: $result"
```

This captures the output of the `ls -l` command and stores it in the `result` variable.

### 2. **Command Substitution:**

The `$()` syntax is more modern and versatile than backticks.

```bash
#!/bin/bash

files_count=$(ls -1 | wc -l)
echo "Number of files in the directory: $files_count"
```

This example uses command substitution to count the number of files in the current directory.

### 3. **Capture Command Output in Variable:**

You can capture the output of a command directly in a variable for further processing.

```bash
#!/bin/bash

current_date=$(date +"%Y-%m-%d")
echo "Current date: $current_date"
```

Here, the `date` command output is stored in the `current_date` variable.

### 4. **Running Commands with Arguments:**

Passing arguments to external commands is straightforward.

```bash
#!/bin/bash

file_name="example.txt"
touch "$file_name"
echo "File created: $file_name"
```

This script uses the `touch` command to create a file named "example.txt."

### 5. **Handling Command Exit Codes:**

Check the exit code to determine if the command was successful.

```bash
#!/bin/bash

if ls non_existent_directory; then
    echo "Directory exists."
else
    echo "Directory does not exist."
fi
```

In this example, the `ls` command checks for the existence of a directory, and the script responds accordingly.

### 6. **Redirecting Command Output:**

Redirect the output of a command to a file.

```bash
#!/bin/bash

ls -l > file_list.txt
echo "File list saved to file_list.txt"
```

This script uses `ls -l` to list files and saves the output to a file named "file_list.txt."

### 7. **Pipelines:**

Combine multiple commands using pipelines.

```bash
#!/bin/bash

# List all files with a .txt extension in the home directory
ls -l ~ | grep ".txt"
```

This script lists files in the home directory and uses `grep` to filter for those with a ".txt" extension.

### 8. **Using Variables in Commands:**

You can use variables within commands.

```bash
#!/bin/bash

directory="/path/to/directory"
files_count=$(ls "$directory" | wc -l)
echo "Number of files in $directory: $files_count"
```

Here, the `ls` command operates on the specified directory stored in the `directory` variable.

### 9. **Quoting Variables:**

Always quote variables to handle spaces and special characters.

```bash
#!/bin/bash

directory="/path with spaces/"
files_count=$(ls "$directory" | wc -l)
echo "Number of files in $directory: $files_count"
```

Quoting ensures that the command works correctly even if the path contains spaces.

### 10. **Security Considerations:**

Be cautious when dealing with user input or variables to prevent command injection vulnerabilities.

```bash
#!/bin/bash

user_input="; rm -rf /"
echo "User input: $user_input"
ls "$user_input"
```

Sanitize and validate user input to avoid unintended consequences like command injection.

By following these practices, you can effectively run external commands from Linux scripts, ensuring reliability, security, and proper handling of command output and errors.



<br>

## Next | [Capturing and using command output](https://github.com/hegdepavankumar/bash-scripting-tutorial/blob/main/Tutorial-Files/16.Interacting-with-External-Commands/02.Capturing%20and%20using%20command%20output.md)
